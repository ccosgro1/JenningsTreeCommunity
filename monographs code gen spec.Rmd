---
title: "GenSpec monographs code"
author: "Colleen Cosgrove"
date: "January 25, 2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r libraries}
library(vegan)
```

```{r Generalists}
treedata=read.csv("C:/Users/Colleen/Dropbox/Jennings 2016/New Adult Basal Area.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
dim(treedata)
names(soildata)
dim(soildata)
treedata$ecosys

treedata[is.na(treedata)] <- 0

# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings
treedata=treedata[treedata$ecosys!="S",]
tree.ringsum=treedata[1:80,]
#This [1:80,] refers to all plots within the first ring.

for(i in 1:80) {
  tree.ringsum[i,10:43]=treedata[i,10:43]+treedata[i+83,10:43]+treedata[i+166,10:43]}
rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun
tree.colsums=apply(tree.ringsum[,10:43],2,sum)
plot(rank(tree.colsums),tree.colsums)
print(tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:43],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:43]=tree.hel[,10:43]/tree.rowsums
tree.hel[,10:43]=sqrt(tree.hel[,10:43])

#### Forward selection using regionalized soil variables
# First we have to merge the datasets
tree.hel.soil=merge(tree.hel,soildata)
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)

## Before continuing, subset data into generalists and specialists.
#generalists
tree.hel.soil.gen=tree.hel.soil[,c(1:11,13:14,16:17,20:21,24,27:28,32:33,36,38,45:79)]

### Generalists ###
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil.gen[,10:24], tree.hel.soil.gen[,35:59])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared


##NEW forward selection
hel.rda.fulsoil.none = rda(tree.hel.soil.gen[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.soil.gen[,10:24], tree.hel.soil.gen[,35:59])

hel.rda.fulsoil.full=rda(tree.hel.soil.gen[,10:24]~tree.hel.soil.gen$Ptot_long+tree.hel.soil.gen$Po_long+tree.hel.soil.gen$pH_long+tree.hel.soil.gen$moist_long +tree.hel.soil.gen$ps1_long+tree.hel.soil.gen$ps2_long+tree.hel.soil.gen$percc_long+tree.hel.soil.gen$cton_long+tree.hel.soil.gen$Ptot_nug+tree.hel.soil.gen$Po_nug+tree.hel.soil.gen$pH_nug+tree.hel.soil.gen$moist_nug+tree.hel.soil.gen$ps1_nug+tree.hel.soil.gen$ps2_nug+tree.hel.soil.gen$percc_nug+tree.hel.soil.gen$pomc_nug+tree.hel.soil.gen$cton_nug+tree.hel.soil.gen$Ptot_short+tree.hel.soil.gen$Po_short+tree.hel.soil.gen$pH_short+tree.hel.soil.gen$moist_short+tree.hel.soil.gen$ps1_short+tree.hel.soil.gen$percc_short+tree.hel.soil.gen$pomc_short+tree.hel.soil.gen$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

# Constructing a model with selected variables.
hel.rda.selsoil = rda(tree.hel.soil.gen[,10:24] ~ as.matrix(tree.hel.soil.gen[,c(35,37,39,41)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil.gen[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil.gen,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil.gen,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,60:102])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,60:102])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:24]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25+tree.hel.all.pcnm$PCNM26+tree.hel.all.pcnm$PCNM27+tree.hel.all.pcnm$PCNM28+tree.hel.all.pcnm$PCNM29+tree.hel.all.pcnm$PCNM30+tree.hel.all.pcnm$PCNM31+tree.hel.all.pcnm$PCNM32+tree.hel.all.pcnm$PCNM33+tree.hel.all.pcnm$PCNM34+tree.hel.all.pcnm$PCNM35+tree.hel.all.pcnm$PCNM36+tree.hel.all.pcnm$PCNM37+tree.hel.all.pcnm$PCNM38+tree.hel.all.pcnm$PCNM39+tree.hel.all.pcnm$PCNM40+tree.hel.all.pcnm$PCNM41+tree.hel.all.pcnm$PCNM42+tree.hel.all.pcnm$PCNM43)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:24] ~ as.matrix(tree.hel.all.pcnm[,c(60:61,65:68)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(35,37,39,41)], tree.hel.all.pcnm[,c(60:61,65:68)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(60:61,65:68)], tree.hel.all.pcnm[,c(35,37,39,41)])
anova(hel.rda.all.partpcnm)
# Yes.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(35,37,39,41)], tree.hel.all.pcnm[,c(60:61,65:68)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.


colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(35,37,39,41)], tree.hel.all.pcnm[,c(60:61,65:68)])


names(tree.hel.all.pcnm)
plot(hel.rda.all.partpcnm)

### Can you try to run this on core only plots or core+edge plots and see how the importance of soil versus spatial structure shifts?
tree.hel.soil.gen1=tree.hel.soil.gen
#Core Plots
tree.hel.soil.gen=tree.hel.soil.gen1[tree.hel.soil.gen1$EP=="Core",]
rownames(tree.hel.soil.gen)=tree.hel.soil.gen[,1]
tree.hel.soil.gen=na.exclude(tree.hel.soil.gen)
colnames(tree.hel.soil.gen)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil.gen[,10:24], tree.hel.soil.gen[,35:59])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

# Here is the forward selection command and then constructing a model with selected variables.
##NEW forward selection
hel.rda.fulsoil.none = rda(tree.hel.soil.gen[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.soil.gen[,10:24], tree.hel.soil.gen[,35:59])

hel.rda.fulsoil.full=rda(tree.hel.soil.gen[,10:24]~tree.hel.soil.gen$Ptot_long+tree.hel.soil.gen$Po_long+tree.hel.soil.gen$pH_long+tree.hel.soil.gen$moist_long +tree.hel.soil.gen$ps1_long+tree.hel.soil.gen$ps2_long+tree.hel.soil.gen$percc_long+tree.hel.soil.gen$cton_long+tree.hel.soil.gen$Ptot_nug+tree.hel.soil.gen$Po_nug+tree.hel.soil.gen$pH_nug+tree.hel.soil.gen$moist_nug+tree.hel.soil.gen$ps1_nug+tree.hel.soil.gen$ps2_nug+tree.hel.soil.gen$percc_nug+tree.hel.soil.gen$pomc_nug+tree.hel.soil.gen$cton_nug+tree.hel.soil.gen$Ptot_short+tree.hel.soil.gen$Po_short+tree.hel.soil.gen$pH_short+tree.hel.soil.gen$moist_short+tree.hel.soil.gen$ps1_short+tree.hel.soil.gen$percc_short+tree.hel.soil.gen$pomc_short+tree.hel.soil.gen$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel


names(tree.hel.soil.gen)
hel.rda.selsoil = rda(tree.hel.soil.gen[,10:24] ~ as.matrix(tree.hel.soil.gen[,c(35,58,37,41)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil.gen[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil.gen,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil.gen,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,60:84])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,60:102])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:24]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:24] ~ as.matrix(tree.hel.all.pcnm[,c(60:64,68)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(35,58,37,41)], tree.hel.all.pcnm[,c(60:64,68)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(60:64,68)], tree.hel.all.pcnm[,c(35,58,37,41)])
anova(hel.rda.all.partpcnm)
# NO.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:43], tree.hel.all.pcnm[,c(35,58,37,41)], tree.hel.all.pcnm[,c(60:64,68)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.


#Core+Edge
tree.hel.soil.gen=tree.hel.soil.gen1[tree.hel.soil.gen1$EP=="Core"|tree.hel.soil.gen1$EP=="Edge",]
rownames(tree.hel.soil.gen)=tree.hel.soil.gen[,1]
tree.hel.soil.gen=na.exclude(tree.hel.soil.gen)
colnames(tree.hel.soil.gen)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil.gen[,10:24], tree.hel.soil.gen[,35:59])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil.gen[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.soil.gen[,10:24], tree.hel.soil.gen[,35:59])

hel.rda.fulsoil.full=rda(tree.hel.soil.gen[,10:24]~tree.hel.soil.gen$Ptot_long+tree.hel.soil.gen$Po_long+tree.hel.soil.gen$pH_long+tree.hel.soil.gen$moist_long +tree.hel.soil.gen$ps1_long+tree.hel.soil.gen$ps2_long+tree.hel.soil.gen$percc_long+tree.hel.soil.gen$cton_long+tree.hel.soil.gen$Ptot_nug+tree.hel.soil.gen$Po_nug+tree.hel.soil.gen$pH_nug+tree.hel.soil.gen$moist_nug+tree.hel.soil.gen$ps1_nug+tree.hel.soil.gen$ps2_nug+tree.hel.soil.gen$percc_nug+tree.hel.soil.gen$pomc_nug+tree.hel.soil.gen$cton_nug+tree.hel.soil.gen$Ptot_short+tree.hel.soil.gen$Po_short+tree.hel.soil.gen$pH_short+tree.hel.soil.gen$moist_short+tree.hel.soil.gen$ps1_short+tree.hel.soil.gen$percc_short+tree.hel.soil.gen$pomc_short+tree.hel.soil.gen$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil.gen)
hel.rda.selsoil = rda(tree.hel.soil.gen[,10:24] ~ as.matrix(tree.hel.soil.gen[,c(35,37,58,41,49)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil.gen[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil.gen,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil.gen,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,60:98])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,60:98])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:24]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25+tree.hel.all.pcnm$PCNM26+tree.hel.all.pcnm$PCNM27+tree.hel.all.pcnm$PCNM28+tree.hel.all.pcnm$PCNM29+tree.hel.all.pcnm$PCNM30+tree.hel.all.pcnm$PCNM31+tree.hel.all.pcnm$PCNM32+tree.hel.all.pcnm$PCNM33+tree.hel.all.pcnm$PCNM34+tree.hel.all.pcnm$PCNM35+tree.hel.all.pcnm$PCNM36+tree.hel.all.pcnm$PCNM37+tree.hel.all.pcnm$PCNM38+tree.hel.all.pcnm$PCNM39)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:24] ~ as.matrix(tree.hel.all.pcnm[,c(61,63,65:67,71)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(35,37,58,41,49)], tree.hel.all.pcnm[,c(61,63,65:67,71)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(61,63,65:67,71)], tree.hel.all.pcnm[,c(35,37,58,41,49)])
anova(hel.rda.all.partpcnm)
# Yes.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(35,37,58,41,49)], tree.hel.all.pcnm[,c(61,63,65:67,71)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.

########new tree data 2016; bonus code########DID NOT DO THIS
###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
rownames(tree.hel.core)
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:24] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
names(tree.hel.edge)
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:43] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
  dat.ec.rand=tree.hel.edge
  dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
  dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
  dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
  dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
  dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
  datcore.rda.ecosys = rda(dat.core.rand[,10:42] ~ dat.core.rand[,3])
  core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
  res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:43],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=41,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:43],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
  dat.ec.rand=jac.edge.pcoa.points
  dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
  dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
  dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
  dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
  dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
  datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
  core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
  res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)
```


```{r gen mortality}
#Mortality
treedata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Research/Data/Trees/Species Mortality Matrix.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
rownames(treedata)=treedata[,1]
dim(treedata)
names(soildata)
rownames(soildata)=soildata[,1]
dim(soildata)
# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings - there's no need to sum the rings here.
treedata=treedata[treedata$Ecosystem!="S",]
dim(treedata)
treedata[is.na(treedata)] <- 0
treedata
treedata=treedata

rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun

tree.colsums=apply(tree.ringsum[,10:42],2,sum)
plot(rank(tree.colsums),tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:42],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:42]=tree.hel[,10:42]/tree.rowsums
tree.hel[,10:42]=sqrt(tree.hel[,10:42])

#### Forward selection using regionalized soil variables
# First we have to merge the datasets
tree.hel.soil=merge(tree.hel,soildata)
rownames(tree.hel.soil)=tree.hel.soil[,1]
colnames(tree.hel.soil)
dim(tree.hel.soil)
tree.hel.soil=na.exclude(tree.hel.soil)

#separate out generalists
tree.hel.soil=tree.hel.soil[,c(1:11,13:14,16:17,20:21,24,27:28,32:33,36,38,43:76)]

# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:24], tree.hel.soil[,34:58])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
## First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
## If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
## Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,59:76])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared


tree.hel.soil1=tree.hel.soil
#Core Plots
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:24], tree.hel.soil[,35:58])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

# Here is the forward selection command and then constructing a model with selected variables.
##NEW forward selection
hel.rda.fulsoil.none = rda(tree.hel.soil[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.soil[,10:24], tree.hel.soil[,35:58])

hel.rda.fulsoil.full=rda(tree.hel.soil[,10:24]~tree.hel.soil$Ptot_long+tree.hel.soil$Po_long+tree.hel.soil$pH_long+tree.hel.soil$moist_long +tree.hel.soil$ps1_long+tree.hel.soil$ps2_long+tree.hel.soil$percc_long+tree.hel.soil$cton_long+tree.hel.soil$Ptot_nug+tree.hel.soil$Po_nug+tree.hel.soil$pH_nug+tree.hel.soil$moist_nug+tree.hel.soil$ps1_nug+tree.hel.soil$ps2_nug+tree.hel.soil$percc_nug+tree.hel.soil$pomc_nug+tree.hel.soil$cton_nug+tree.hel.soil$Ptot_short+tree.hel.soil$Po_short+tree.hel.soil$pH_short+tree.hel.soil$moist_short+tree.hel.soil$ps1_short+tree.hel.soil$percc_short+tree.hel.soil$pomc_short+tree.hel.soil$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel


names(tree.hel.soil)
hel.rda.selsoil = rda(tree.hel.soil[,10:24] ~ as.matrix(tree.hel.soil[,c(38:39)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,58:76])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,58:76])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:24]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:24] ~ as.matrix(tree.hel.all.pcnm[,c(59,61,70)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(38:39)], tree.hel.all.pcnm[,c(59,61,70)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(59,61,70)], tree.hel.all.pcnm[,c(38:39)])
anova(hel.rda.all.partpcnm)
# NO.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,c(59,61,70)], tree.hel.all.pcnm[,c(38:39)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.


#Core+Edge
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core"|tree.hel.soil1$EP=="Edge",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:24], tree.hel.soil[,35:58])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,59:76])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:24]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,59:76])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:24]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:24] ~ as.matrix(tree.hel.all.pcnm[,c(59,61,70)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
is.na(tree.hel)
tree.hel[is.na(tree.hel)] <- 0
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:24] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:24] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:42] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:24],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=41,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:24],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=jac.edge.pcoa.points
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)

goodness(jac.core.rda.ecosys)
goodness(jac.edge.rda.ecosys)
```
```{r gen recruitment}
##Recruitment
treedata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Research/Data/Trees/General transition graph files/Species Recruitment Matrix.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
dim(treedata)
names(soildata)
dim(soildata)
# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings
treedata=treedata[treedata$Ecosystem!="S",]

treedata[is.na(treedata)] <- 0

dim(treedata)
tree.ringsum=treedata

rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun
tree.colsums=apply(tree.ringsum[,10:35],2,sum)
plot(rank(tree.colsums),tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:35],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:35]=tree.hel[,10:35]/tree.rowsums
tree.hel[,10:35]=sqrt(tree.hel[,10:35])


#### Forward selection using regionalized soil variables
# First we have to merge the datasets
rownames(soildata)=soildata$Plot
rownames(tree.hel)=treedata$Plot
tree.hel.soil=merge(tree.hel,soildata)
rownames(tree.hel.soil)=tree.hel.soil$Plot
is.na(tree.hel.soil)
tree.hel.soil=na.exclude(tree.hel.soil)
dim(tree.hel.soil)

#separate out the generalists
tree.hel.soil=tree.hel.soil[,c(1:13,15,19:20,23,25:27,30:31,38:71)]

# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:22], tree.hel.soil[,32:56])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared
##Not significant. We do not perform forward selection.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:22], tree.hel.all.pcnm[,57:92])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

###Signficant, so we run the following code:
##now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:22]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:22], tree.hel.all.pcnm[,57:92])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:22]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25+tree.hel.all.pcnm$PCNM26+tree.hel.all.pcnm$PCNM27+tree.hel.all.pcnm$PCNM28+tree.hel.all.pcnm$PCNM29+tree.hel.all.pcnm$PCNM30+tree.hel.all.pcnm$PCNM31+tree.hel.all.pcnm$PCNM32+tree.hel.all.pcnm$PCNM33+tree.hel.all.pcnm$PCNM34+tree.hel.all.pcnm$PCNM35+tree.hel.all.pcnm$PCNM36)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
## Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:22] ~ as.matrix(tree.hel.all.pcnm[,c(57:58,67,79,89,92)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)
# No need for variance partitioning since there is no soil effect.

tree.hel.soil1=tree.hel.soil
#Core Plots
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:22], tree.hel.soil[,35:56])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:22], tree.hel.all.pcnm[,57:77])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

#Core+Edge
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core"|tree.hel.soil1$EP=="Edge",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:22], tree.hel.soil[,32:56])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,57:90])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:22] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:22] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:35] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:22],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=34,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:22],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=jac.edge.pcoa.points
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)

goodness(jac.core.rda.ecosys)
goodness(jac.edge.rda.ecosys)
```
```{r gen growth}
###Species Growth
treedata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Research/Data/Trees/Species Growth Matrix.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
dim(treedata)
names(soildata)
dim(soildata)
# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings - there's no need to sum the rings here.
treedata=treedata[treedata$ecosys!="S",]
dim(treedata)
treedata[is.na(treedata)] <- 0
tree.ringsum=treedata
rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun
tree.colsums=apply(tree.ringsum[,10:35],2,sum)
plot(rank(tree.colsums),tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:43],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:43]=tree.hel[,10:43]/tree.rowsums
tree.hel[,10:43]=sqrt(tree.hel[,10:43])

#### Forward selection using regionalized soil variables
# First we have to merge the datasets
dim(tree.hel)
dim(soildata)
rownames(soildata)=soildata$Plot
tree.hel.soil=merge(tree.hel,soildata)
dim(tree.hel.soil)
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
names(tree.hel.soil)
dim(tree.hel.soil)

#separate out the generalists
tree.hel.soil=tree.hel.soil[,c(1:11,13:14,16,19:20,23,26:27,31:32,35,37,45:78)]

# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:23], tree.hel.soil[,33:57])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared
# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil[,10:23]~1)
hel.rda.fulsoil = rda(tree.hel.soil[,10:23], tree.hel.soil[,33:57])

hel.rda.fulsoil.full=rda(tree.hel.soil[,10:23]~tree.hel.soil$Ptot_long+tree.hel.soil$Po_long+tree.hel.soil$pH_long+tree.hel.soil$moist_long +tree.hel.soil$ps1_long+tree.hel.soil$ps2_long+tree.hel.soil$percc_long+tree.hel.soil$cton_long+tree.hel.soil$Ptot_nug+tree.hel.soil$Po_nug+tree.hel.soil$pH_nug+tree.hel.soil$moist_nug+tree.hel.soil$ps1_nug+tree.hel.soil$ps2_nug+tree.hel.soil$percc_nug+tree.hel.soil$pomc_nug+tree.hel.soil$cton_nug+tree.hel.soil$Ptot_short+tree.hel.soil$Po_short+tree.hel.soil$pH_short+tree.hel.soil$moist_short+tree.hel.soil$ps1_short+tree.hel.soil$percc_short+tree.hel.soil$pomc_short+tree.hel.soil$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil)
hel.rda.selsoil = rda(tree.hel.soil[,10:23] ~ as.matrix(tree.hel.soil[,c(37:38)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:23], tree.hel.all.pcnm[,58,91])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
#No need for variance partitioning since there is no spatial significance.

tree.hel.soil1=tree.hel.soil
#Core Plots
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:23], tree.hel.soil[,33:57])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:23], tree.hel.all.pcnm[,58:75])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:23]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:23], tree.hel.all.pcnm[,58:75])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:22]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
## Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:28] ~ as.matrix(tree.hel.all.pcnm[,c(58,60:61)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)
# No need for variance partitioning since there is no soil effect.


#Core+Edge
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core"|tree.hel.soil1$EP=="Edge",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:23], tree.hel.soil[,33:57])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:23], tree.hel.all.pcnm[,58:88])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

## Extra code
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:23] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}


###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
ncol(tree.hel.core)
tree.hel.core=na.omit(tree.hel.core)
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:23] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
tree.hel.edge=na.omit(tree.hel.edge)
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:23] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:44] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:23],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=42,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:23],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=jac.edge.pcoa.points
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)

goodness(jac.core.rda.ecosys)
goodness(jac.edge.rda.ecosys)
```

```{r specialists}
## Specialists ##
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
tree.hel.soil.spec1=tree.hel.soil.spec
hel.rda.fulsoil = rda(tree.hel.soil.spec[,10:29], tree.hel.soil.spec[,40:64])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil.spec[,10:29]~1)
hel.rda.fulsoil = rda(tree.hel.soil.spec[,10:29], tree.hel.soil.spec[,40:64])

hel.rda.fulsoil.full=rda(tree.hel.soil.spec[,10:29]~tree.hel.soil.spec$Ptot_long+tree.hel.soil.spec$Po_long+tree.hel.soil.spec$pH_long+tree.hel.soil.spec$moist_long +tree.hel.soil.spec$ps1_long+tree.hel.soil.spec$ps2_long+tree.hel.soil.spec$percc_long+tree.hel.soil.spec$cton_long+tree.hel.soil.spec$Ptot_nug+tree.hel.soil.spec$Po_nug+tree.hel.soil.spec$pH_nug+tree.hel.soil.spec$moist_nug+tree.hel.soil.spec$ps1_nug+tree.hel.soil.spec$ps2_nug+tree.hel.soil.spec$percc_nug+tree.hel.soil.spec$pomc_nug+tree.hel.soil.spec$cton_nug+tree.hel.soil.spec$Ptot_short+tree.hel.soil.spec$Po_short+tree.hel.soil.spec$pH_short+tree.hel.soil.spec$moist_short+tree.hel.soil.spec$ps1_short+tree.hel.soil.spec$percc_short+tree.hel.soil.spec$pomc_short+tree.hel.soil.spec$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil.spec)
hel.rda.selsoil = rda(tree.hel.soil.spec[,10:29] ~ as.matrix(tree.hel.soil.spec[,c(43,42,57)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil.spec[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil.spec,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil.spec,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,65:107])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:29]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,60:102])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:29]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25+tree.hel.all.pcnm$PCNM26+tree.hel.all.pcnm$PCNM27+tree.hel.all.pcnm$PCNM28+tree.hel.all.pcnm$PCNM29+tree.hel.all.pcnm$PCNM30+tree.hel.all.pcnm$PCNM31+tree.hel.all.pcnm$PCNM32+tree.hel.all.pcnm$PCNM33+tree.hel.all.pcnm$PCNM34+tree.hel.all.pcnm$PCNM35+tree.hel.all.pcnm$PCNM36+tree.hel.all.pcnm$PCNM37+tree.hel.all.pcnm$PCNM38+tree.hel.all.pcnm$PCNM39+tree.hel.all.pcnm$PCNM40+tree.hel.all.pcnm$PCNM41+tree.hel.all.pcnm$PCNM42+tree.hel.all.pcnm$PCNM43)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:29] ~ as.matrix(tree.hel.all.pcnm[,c(65:67,71,73,104:105)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,c(43,42,57)], tree.hel.all.pcnm[,c(65:67,71,73,104:105)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,c(65:67,71,73,104:105)], tree.hel.all.pcnm[,c(43,42,57)])
anova(hel.rda.all.partpcnm)
# Yes.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,c(43,42,57)], tree.hel.all.pcnm[,c(65:67,71,73,104:105)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.


colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:43], tree.hel.all.pcnm[,c(77:81,83:86)], tree.hel.all.pcnm[,c(86,80,88,82,81,90)])


names(tree.hel.all.pcnm)
plot(hel.rda.all.partpcnm)

### Can you try to run this on core only plots or core+edge plots and see how the importance of soil versus spatial structure shifts?

#Core Plots
tree.hel.soil.spec=tree.hel.soil.spec1[tree.hel.soil.spec1$EP=="Core",]
rownames(tree.hel.soil.spec)=tree.hel.soil.spec[,1]
tree.hel.soil.spec=na.exclude(tree.hel.soil.spec)
colnames(tree.hel.soil.spec)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil.spec[,10:29], tree.hel.soil.spec[,40:64])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil.spec[,10:29]~1)
hel.rda.fulsoil = rda(tree.hel.soil.spec[,10:29], tree.hel.soil.spec[,40:64])

hel.rda.fulsoil.full=rda(tree.hel.soil.spec[,10:29]~tree.hel.soil.spec$Ptot_long+tree.hel.soil.spec$Po_long+tree.hel.soil.spec$pH_long+tree.hel.soil.spec$moist_long +tree.hel.soil.spec$ps1_long+tree.hel.soil.spec$ps2_long+tree.hel.soil.spec$percc_long+tree.hel.soil.spec$cton_long+tree.hel.soil.spec$Ptot_nug+tree.hel.soil.spec$Po_nug+tree.hel.soil.spec$pH_nug+tree.hel.soil.spec$moist_nug+tree.hel.soil.spec$ps1_nug+tree.hel.soil.spec$ps2_nug+tree.hel.soil.spec$percc_nug+tree.hel.soil.spec$pomc_nug+tree.hel.soil.spec$cton_nug+tree.hel.soil.spec$Ptot_short+tree.hel.soil.spec$Po_short+tree.hel.soil.spec$pH_short+tree.hel.soil.spec$moist_short+tree.hel.soil.spec$ps1_short+tree.hel.soil.spec$percc_short+tree.hel.soil.spec$pomc_short+tree.hel.soil.spec$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil.spec)
hel.rda.selsoil = rda(tree.hel.soil.spec[,10:29] ~ as.matrix(tree.hel.soil.spec[,c(40,46,60)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil.spec[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil.spec,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil.spec,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,65:89])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
#hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:29]~1)
#hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,60:102])

#hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:29]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25+tree.hel.all.pcnm$PCNM26+tree.hel.all.pcnm$PCNM27+tree.hel.all.pcnm$PCNM28+tree.hel.all.pcnm$PCNM29+tree.hel.all.pcnm$PCNM30+tree.hel.all.pcnm$PCNM31+tree.hel.all.pcnm$PCNM32+tree.hel.all.pcnm$PCNM33+tree.hel.all.pcnm$PCNM34+tree.hel.all.pcnm$PCNM35+tree.hel.all.pcnm$PCNM36+tree.hel.all.pcnm$PCNM37+tree.hel.all.pcnm$PCNM38+tree.hel.all.pcnm$PCNM39+tree.hel.all.pcnm$PCNM40+tree.hel.all.pcnm$PCNM41+tree.hel.all.pcnm$PCNM42+tree.hel.all.pcnm$PCNM43)

#tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
#tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:43] ~ as.matrix(tree.hel.all.pcnm[,c(80,85,81,82,83,84,86,87,89)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:43], tree.hel.all.pcnm[,c(88,90:104)], tree.hel.all.pcnm[,c(80,85,81,82,83,84,86,87,89)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:43], tree.hel.all.pcnm[,c(88,90:104)], tree.hel.all.pcnm[,c(80,85,81,82,83,84,86,87,89)])
anova(hel.rda.all.partpcnm)
# NO.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:43], tree.hel.all.pcnm[,c(80,85,81,82,83,84,86,87,89)], tree.hel.all.pcnm[,c(88,90:104)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.


#Core+Edge
tree.hel.soil.spec=tree.hel.soil.spec1[tree.hel.soil.spec1$EP=="Core"|tree.hel.soil.spec1$EP=="Edge",]
rownames(tree.hel.soil.spec)=tree.hel.soil.spec[,1]
tree.hel.soil.spec=na.exclude(tree.hel.soil.spec)
colnames(tree.hel.soil.spec)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil.spec[,10:29], tree.hel.soil.spec[,40:64])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil.spec[,10:29]~1)
hel.rda.fulsoil = rda(tree.hel.soil.spec[,10:29], tree.hel.soil.spec[,40:64])

hel.rda.fulsoil.full=rda(tree.hel.soil.spec[,10:29]~tree.hel.soil.spec$Ptot_long+tree.hel.soil.spec$Po_long+tree.hel.soil.spec$pH_long+tree.hel.soil.spec$moist_long +tree.hel.soil.spec$ps1_long+tree.hel.soil.spec$ps2_long+tree.hel.soil.spec$percc_long+tree.hel.soil.spec$cton_long+tree.hel.soil.spec$Ptot_nug+tree.hel.soil.spec$Po_nug+tree.hel.soil.spec$pH_nug+tree.hel.soil.spec$moist_nug+tree.hel.soil.spec$ps1_nug+tree.hel.soil.spec$ps2_nug+tree.hel.soil.spec$percc_nug+tree.hel.soil.spec$pomc_nug+tree.hel.soil.spec$cton_nug+tree.hel.soil.spec$Ptot_short+tree.hel.soil.spec$Po_short+tree.hel.soil.spec$pH_short+tree.hel.soil.spec$moist_short+tree.hel.soil.spec$ps1_short+tree.hel.soil.spec$percc_short+tree.hel.soil.spec$pomc_short+tree.hel.soil.spec$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil.spec)
hel.rda.selsoil = rda(tree.hel.soil.spec[,10:29] ~ as.matrix(tree.hel.soil.spec[,c(43,42,60)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil.spec[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil.spec,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil.spec,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,65:103])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
# now run step 2, the selection part
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:29]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,60:103])

hel.rda.fulsoil.full=rda(tree.hel.all.pcnm[,10:29]~tree.hel.all.pcnm$PCNM1+tree.hel.all.pcnm$PCNM2+tree.hel.all.pcnm$PCNM3+tree.hel.all.pcnm$PCNM4+tree.hel.all.pcnm$PCNM5+tree.hel.all.pcnm$PCNM6+tree.hel.all.pcnm$PCNM7+tree.hel.all.pcnm$PCNM8+tree.hel.all.pcnm$PCNM9+tree.hel.all.pcnm$PCNM10+tree.hel.all.pcnm$PCNM11+tree.hel.all.pcnm$PCNM12+tree.hel.all.pcnm$PCNM13+tree.hel.all.pcnm$PCNM14+tree.hel.all.pcnm$PCNM15+tree.hel.all.pcnm$PCNM16+tree.hel.all.pcnm$PCNM17+tree.hel.all.pcnm$PCNM18+tree.hel.all.pcnm$PCNM19+tree.hel.all.pcnm$PCNM20+tree.hel.all.pcnm$PCNM21+tree.hel.all.pcnm$PCNM22+tree.hel.all.pcnm$PCNM23+tree.hel.all.pcnm$PCNM24+tree.hel.all.pcnm$PCNM25+tree.hel.all.pcnm$PCNM26+tree.hel.all.pcnm$PCNM27+tree.hel.all.pcnm$PCNM28+tree.hel.all.pcnm$PCNM29+tree.hel.all.pcnm$PCNM30+tree.hel.all.pcnm$PCNM31+tree.hel.all.pcnm$PCNM32+tree.hel.all.pcnm$PCNM33+tree.hel.all.pcnm$PCNM34+tree.hel.all.pcnm$PCNM35+tree.hel.all.pcnm$PCNM36+tree.hel.all.pcnm$PCNM37+tree.hel.all.pcnm$PCNM38+tree.hel.all.pcnm$PCNM39)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
# Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:43] ~ as.matrix(tree.hel.all.pcnm[,c(65:66,68,73:74,78,101)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

# Now that we have these parsimonious models, NOW WE CAN PERFORM VARIANCE PARTITIONING!  Hurray!
colnames(tree.hel.all.pcnm)
varpart(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,c(43,42,60)], tree.hel.all.pcnm[,c(65:66,68,73:74,78,101)])
# The variance explained by soil variables and spatial structure clearly overlap. 
# It also appears that there is more independent spatial structure in the trees than independent structuring by soil.
# Are the soil variables significant after accounting for spatial structure, and vice versa?
# Let's see.
hel.rda.all.partpcnm=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,c(65:66,68,73:74,78,101)], tree.hel.all.pcnm[,c(43,42,60)])
anova(hel.rda.all.partpcnm)
# Yes.
hel.rda.all.partsoil=rda(tree.hel.all.pcnm[,10:29], tree.hel.all.pcnm[,c(43,42,60)], tree.hel.all.pcnm[,c(65:66,68,73:74,78,101)])
anova(hel.rda.all.partsoil)
# Also yes.  But only by p-value; that is really not much variance explained anymore.


###new tree data 2016; bonus code##
###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
rownames(tree.hel.core)
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:43] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
names(tree.hel.edge)
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:43] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
  dat.ec.rand=tree.hel.edge
  dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
  dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
  dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
  dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
  dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
  datcore.rda.ecosys = rda(dat.core.rand[,10:42] ~ dat.core.rand[,3])
  core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
  res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:43],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=41,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:43],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
  dat.ec.rand=jac.edge.pcoa.points
  dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
  dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
  dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
  dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
  dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
  datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
  core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
  res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)
```


```{r spec mortalirt}
#Mortality
treedata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Research/Data/Trees/Species Mortality Matrix.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
rownames(treedata)=treedata[,1]
dim(treedata)
names(soildata)
rownames(soildata)=soildata[,1]
dim(soildata)
# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings - there's no need to sum the rings here.
treedata=treedata[treedata$Ecosystem!="S",]
dim(treedata)
treedata[is.na(treedata)] <- 0
treedata

tree.ringsum=treedata
rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun

tree.colsums=apply(tree.ringsum[,10:42],2,sum)
plot(rank(tree.colsums),tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:42],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:42]=tree.hel[,10:42]/tree.rowsums
tree.hel[,10:42]=sqrt(tree.hel[,10:42])

#### Forward selection using regionalized soil variables
# First we have to merge the datasets
tree.hel.soil=merge(tree.hel,soildata)
rownames(tree.hel.soil)=tree.hel.soil[,1]
colnames(tree.hel.soil)
dim(tree.hel.soil)
is.na(tree.hel.soil)
tree.hel.soil=na.exclude(tree.hel.soil)

#separate out specialists
tree.hel.soil=tree.hel.soil[,c(1:9,12,15,18:19,22:23,25:26,29:31,34:35,37,39:76)]

# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:27], tree.hel.soil[,37:61])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared
# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil[,10:27]~1)
hel.rda.fulsoil = rda(tree.hel.soil[,10:27], tree.hel.soil[,37:61])

hel.rda.fulsoil.full=rda(tree.hel.soil[,10:27]~tree.hel.soil$Ptot_long+tree.hel.soil$Po_long+tree.hel.soil$pH_long+tree.hel.soil$moist_long +tree.hel.soil$ps1_long+tree.hel.soil$ps2_long+tree.hel.soil$percc_long+tree.hel.soil$cton_long+tree.hel.soil$Ptot_nug+tree.hel.soil$Po_nug+tree.hel.soil$pH_nug+tree.hel.soil$moist_nug+tree.hel.soil$ps1_nug+tree.hel.soil$ps2_nug+tree.hel.soil$percc_nug+tree.hel.soil$pomc_nug+tree.hel.soil$cton_nug+tree.hel.soil$Ptot_short+tree.hel.soil$Po_short+tree.hel.soil$pH_short+tree.hel.soil$moist_short+tree.hel.soil$ps1_short+tree.hel.soil$percc_short+tree.hel.soil$pomc_short+tree.hel.soil$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil)
hel.rda.selsoil = rda(tree.hel.soil[,10:27] ~ as.matrix(tree.hel.soil[,c(61,40)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
## First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
## If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
## Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:27], tree.hel.all.pcnm[,3])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
###Not signficant, so we don't run a forward selection or variance partioning

tree.hel.soil1=tree.hel.soil
#Core Plots
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:27], tree.hel.soil[,37:61])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,37:61])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

#Core+Edge
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core"|tree.hel.soil1$EP=="Edge",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:24], tree.hel.soil[,37:61])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,37:61])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
is.na(tree.hel)
tree.hel[is.na(tree.hel)] <- 0
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:27] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:27] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:42] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:27],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=41,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:27],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=jac.edge.pcoa.points
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)

goodness(jac.core.rda.ecosys)
goodness(jac.edge.rda.ecosys)
```
```{r spec recruitment}
##Recruitment
treedata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Research/Data/Trees/General transition graph files/Species Recruitment Matrix.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
dim(treedata)
names(soildata)
dim(soildata)
# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings
treedata=treedata[treedata$Ecosystem!="S",]

treedata[is.na(treedata)] <- 0

dim(treedata)
tree.ringsum=treedata

rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun
tree.colsums=apply(tree.ringsum[,10:35],2,sum)
plot(rank(tree.colsums),tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:35],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:35]=tree.hel[,10:35]/tree.rowsums
tree.hel[,10:35]=sqrt(tree.hel[,10:35])


#### Forward selection using regionalized soil variables
# First we have to merge the datasets
rownames(soildata)=soildata$Plot
rownames(tree.hel)=treedata$Plot
tree.hel.soil=merge(tree.hel,soildata)
rownames(tree.hel.soil)=tree.hel.soil$Plot
is.na(tree.hel.soil)
tree.hel.soil=na.exclude(tree.hel.soil)
dim(tree.hel.soil)

#separate out the specialists
tree.hel.soil=tree.hel.soil[,c(1:9,14,17,21:22,24,28:29,32:71)]

# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:20], tree.hel.soil[,32:56])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared
##Not significant. So we do not perform forward selection

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:20], tree.hel.all.pcnm[,57:92])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
###Not signficant, so we don't forward selection or variane partitioning

tree.hel.soil1=tree.hel.soil
#Core Plots
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:20], tree.hel.soil[,32:56])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:24], tree.hel.all.pcnm[,58:76])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

#Core+Edge
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core"|tree.hel.soil1$EP=="Edge",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:20], tree.hel.soil[,32:56])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:20], tree.hel.all.pcnm[,57:90])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:20] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:20] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:20] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:20],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=34,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:20],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=jac.edge.pcoa.points
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)

goodness(jac.core.rda.ecosys)
goodness(jac.edge.rda.ecosys)
```
```{r spec growth}
treedata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Research/Data/Trees/Species Growth Matrix.csv")
soildata=read.csv("C:/Users/Colleen/OneDrive/Documents/School/Grad School/SpatialStats/soil data May 08 for tree plots.csv")
names(treedata)
dim(treedata)
names(soildata)
dim(soildata)
# The tree data was collected in three rings for each plot
# We are going to exclude stream plots (no soil data) and then sum the three rings - there's no need to sum the rings here.
treedata=treedata[treedata$ecosys!="S",]
dim(treedata)
treedata[is.na(treedata)] <- 0
tree.ringsum=treedata
rownames(tree.ringsum)=tree.ringsum[,1]
# Let's look at a rank abbundance plot for fun
tree.colsums=apply(tree.ringsum[,10:35],2,sum)
plot(rank(tree.colsums),tree.colsums)

# Perform Hellinger transformation on tree species data so that RDA is based on Hellinger distance
tree.rowsums=apply(tree.ringsum[,10:43],1,sum)
tree.hel=tree.ringsum
tree.hel[,10:43]=tree.hel[,10:43]/tree.rowsums
tree.hel[,10:43]=sqrt(tree.hel[,10:43])

#### Forward selection using regionalized soil variables
# First we have to merge the datasets
dim(tree.hel)
dim(soildata)
rownames(soildata)=soildata$Plot
tree.hel.soil=merge(tree.hel,soildata)
dim(tree.hel.soil)
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
names(tree.hel.soil)
dim(tree.hel.soil)
rownames(tree.hel.soil)

#separate out the specialists
tree.hel.soil=tree.hel.soil[,c(1:9,12,15,17,21:22,24:25,28:30,33:34,36,38:78)]

# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:28], tree.hel.soil[,39:63])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared
# Here is the forward selection command and then constructing a model with selected variables.
hel.rda.fulsoil.none = rda(tree.hel.soil[,10:28]~1)
hel.rda.fulsoil = rda(tree.hel.soil[,10:28], tree.hel.soil[,39:63])

hel.rda.fulsoil.full=rda(tree.hel.soil[,10:28]~tree.hel.soil$Ptot_long+tree.hel.soil$Po_long+tree.hel.soil$pH_long+tree.hel.soil$moist_long +tree.hel.soil$ps1_long+tree.hel.soil$ps2_long+tree.hel.soil$percc_long+tree.hel.soil$cton_long+tree.hel.soil$Ptot_nug+tree.hel.soil$Po_nug+tree.hel.soil$pH_nug+tree.hel.soil$moist_nug+tree.hel.soil$ps1_nug+tree.hel.soil$ps2_nug+tree.hel.soil$percc_nug+tree.hel.soil$pomc_nug+tree.hel.soil$cton_nug+tree.hel.soil$Ptot_short+tree.hel.soil$Po_short+tree.hel.soil$pH_short+tree.hel.soil$moist_short+tree.hel.soil$ps1_short+tree.hel.soil$percc_short+tree.hel.soil$pomc_short+tree.hel.soil$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil)
hel.rda.selsoil = rda(tree.hel.soil[,10:28] ~ as.matrix(tree.hel.soil[,c(41:42)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)
# Cool analysis, but what a terrible plot.  Much better to get the scores and plot them in a real graphing program, or do some fancy graphing in R if that is your thing.

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:28], tree.hel.all.pcnm[,64:97])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared
##End. No significance, so no reason to continue.

tree.hel.soil1=tree.hel.soil
#Core Plots
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:28], tree.hel.soil[,39:63])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:28], tree.hel.all.pcnm[,64:81])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

names(tree.hel.all.pcnm)
#Forward selection
hel.rda.fulsoil.none = rda(tree.hel.all.pcnm[,10:28]~1)
hel.rda.fulsoil = rda(tree.hel.all.pcnm[,10:28], tree.hel.all.pcnm[,64:81])

hel.rda.fulsoil.full=rda(tree.hel.soil[,10:28]~tree.hel.soil$Ptot_long+tree.hel.soil$Po_long+tree.hel.soil$pH_long+tree.hel.soil$moist_long +tree.hel.soil$ps1_long+tree.hel.soil$ps2_long+tree.hel.soil$percc_long+tree.hel.soil$cton_long+tree.hel.soil$Ptot_nug+tree.hel.soil$Po_nug+tree.hel.soil$pH_nug+tree.hel.soil$moist_nug+tree.hel.soil$ps1_nug+tree.hel.soil$ps2_nug+tree.hel.soil$percc_nug+tree.hel.soil$pomc_nug+tree.hel.soil$cton_nug+tree.hel.soil$Ptot_short+tree.hel.soil$Po_short+tree.hel.soil$pH_short+tree.hel.soil$moist_short+tree.hel.soil$ps1_short+tree.hel.soil$percc_short+tree.hel.soil$pomc_short+tree.hel.soil$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel
## Let's store a model using the selected variables only
names(tree.hel.all.pcnm)
hel.rda.all.selpcnm = rda(tree.hel.all.pcnm[,10:28] ~ as.matrix(tree.hel.all.pcnm[,c(41:42,63)]))
anova(hel.rda.all.selpcnm)
RsquareAdj(hel.rda.all.selpcnm)

#Core+Edge
tree.hel.soil=tree.hel.soil1[tree.hel.soil1$EP=="Core"|tree.hel.soil1$EP=="Edge",]
rownames(tree.hel.soil)=tree.hel.soil[,1]
tree.hel.soil=na.exclude(tree.hel.soil)
colnames(tree.hel.soil)
# Here is the global analysis. Can proceed if significant.  Use adj. R square as additional stopping criterion.
hel.rda.fulsoil = rda(tree.hel.soil[,10:28], tree.hel.soil[,39:63])
anova(hel.rda.fulsoil)
RsquareAdj(hel.rda.fulsoil)
global.thresh=RsquareAdj(hel.rda.fulsoil)$adj.r.squared

hel.rda.fulsoil.none = rda(tree.hel.soil[,10:28]~1)
hel.rda.fulsoil = rda(tree.hel.soil[,10:28], tree.hel.soil[,39:63])

hel.rda.fulsoil.full=rda(tree.hel.soil[,10:28]~tree.hel.soil$Ptot_long+tree.hel.soil$Po_long+tree.hel.soil$pH_long+tree.hel.soil$moist_long +tree.hel.soil$ps1_long+tree.hel.soil$ps2_long+tree.hel.soil$percc_long+tree.hel.soil$cton_long+tree.hel.soil$Ptot_nug+tree.hel.soil$Po_nug+tree.hel.soil$pH_nug+tree.hel.soil$moist_nug+tree.hel.soil$ps1_nug+tree.hel.soil$ps2_nug+tree.hel.soil$percc_nug+tree.hel.soil$pomc_nug+tree.hel.soil$cton_nug+tree.hel.soil$Ptot_short+tree.hel.soil$Po_short+tree.hel.soil$pH_short+tree.hel.soil$moist_short+tree.hel.soil$ps1_short+tree.hel.soil$percc_short+tree.hel.soil$pomc_short+tree.hel.soil$cton_short)

tree.sel=ordiR2step(hel.rda.fulsoil.none,scope=formula(hel.rda.fulsoil.full),Pin=0.05,R2scope=TRUE)
tree.sel

names(tree.hel.soil)
hel.rda.selsoil = rda(tree.hel.soil[,10:28] ~ as.matrix(tree.hel.soil[,c(41:42)]))
anova(hel.rda.selsoil)
RsquareAdj(hel.rda.selsoil)
plot(hel.rda.selsoil)

#### Forward selection using PCNM vectors
# First we perform PCNM to get the vectors
all.geog.dist=vegdist(tree.hel.soil[,8:9],method="euclid")
all.pcnm1=pcnm(all.geog.dist)
all.pcnmvecs=all.pcnm1$vectors
# If you can get the PCNM library to run, you could do the line below to select only significantly structured PCNMs
#tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs[,which(all.pcnm1$Moran_I[,2]<0.05)])
tree.hel.all.pcnm=cbind(tree.hel.soil,all.pcnmvecs)
names(tree.hel.all.pcnm)
# Now run step 1, global analysis
hel.rda.all.fulpcnm=rda(tree.hel.all.pcnm[,10:28], tree.hel.all.pcnm[,64:94])
anova(hel.rda.all.fulpcnm)
RsquareAdj(hel.rda.all.fulpcnm)
global.thresh=RsquareAdj(hel.rda.all.fulpcnm)$adj.r.squared

###### Some Bonus tree code
# Here is a quick analysis to test for the edge effect on tree communities when Ecosystem type is the explanatory factor, just like we did before with soil data
# First the core plots
tree.hel.core=tree.hel[tree.hel$EP=="Core",]
ncol(tree.hel.core)
tree.hel.core=na.omit(tree.hel.core)
tree.hel.core.rda.ecosys = rda(tree.hel.core[,10:28] ~ tree.hel.core[,3])
anova(tree.hel.core.rda.ecosys)
core.arsq=RsquareAdj(tree.hel.core.rda.ecosys)
# Then the core+edge plots
tree.hel.edge=tree.hel[tree.hel$EP=="Core"|tree.hel$EP=="Edge",]
tree.hel.edge=na.omit(tree.hel.edge)
tree.hel.edge.rda.ecosys = rda(tree.hel.edge[,10:28] ~ tree.hel.edge[,3])
anova(tree.hel.edge.rda.ecosys)
edge.arsq=RsquareAdj(tree.hel.edge.rda.ecosys)
# Then the permmutation test of the edge effect
edge.eff=core.arsq$adj.r.squared/edge.arsq$adj.r.squared
# The permutation test for significance of edge effect
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=tree.hel.edge
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,10:28] ~ dat.core.rand[,3])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,edge.eff))
1-tiles[nperm+1]/(nperm+1)
# How well is each species fitted by these models?  Find out below.
goodness(tree.hel.core.rda.ecosys)
goodness(tree.hel.edge.rda.ecosys)

##Same idea as above, but Jaccard distance analysis by PCoA/distance-based RDA
jac.core.dist=vegdist(tree.hel.core[,10:28],method="jaccard",binary=TRUE)
jac.core.pcoa=cmdscale(jac.core.dist,eig=TRUE,k=42,add=TRUE)
jac.core.rda.ecosys = rda(jac.core.pcoa$points ~ tree.hel.core[,3])
anova(jac.core.rda.ecosys)
jac.core.arsq=RsquareAdj(jac.core.rda.ecosys)
jac.edge.dist=vegdist(tree.hel.edge[,10:28],method="jaccard",binary=TRUE)
jac.edge.pcoa=cmdscale(jac.edge.dist,eig=TRUE,k=70,add=TRUE)
jac.edge.pcoa.points=cbind(jac.edge.pcoa$points,tree.hel.edge)
jac.edge.rda.ecosys = rda(jac.edge.pcoa.points[,1:70] ~ jac.edge.pcoa.points[,73])
anova(jac.edge.rda.ecosys)
jac.edge.arsq=RsquareAdj(jac.edge.rda.ecosys)
jac.edge.eff=jac.core.arsq$adj.r.squared/jac.edge.arsq$adj.r.squared
nperm=999
res.vec=matrix(nrow=nperm,ncol=1,0)
for(i in 1:nperm){
	dat.ec.rand=jac.edge.pcoa.points
	dat.ec.rand[dat.ec.rand$ecosys=="B",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="B",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="B",]))
	dat.ec.rand[dat.ec.rand$ecosys=="R",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="R",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="R",]))
	dat.ec.rand[dat.ec.rand$ecosys=="U",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="U",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="U",]))
	dat.ec.rand[dat.ec.rand$ecosys=="D",5]=sample(dat.ec.rand[dat.ec.rand$ecosys=="D",5],size=nrow(dat.ec.rand[dat.ec.rand$ecosys=="D",]))
	dat.core.rand=dat.ec.rand[dat.ec.rand$EP=="Core",]
	datcore.rda.ecosys = rda(dat.core.rand[,1:70] ~ dat.core.rand[,73])
	core.arsq.rand=RsquareAdj(datcore.rda.ecosys)
	res.vec[i]=core.arsq.rand$adj.r.squared/jac.edge.arsq$adj.r.squared
}
tiles=rank(rbind(res.vec,jac.edge.eff))
1-tiles[nperm+1]/(nperm+1)

goodness(jac.core.rda.ecosys)
goodness(jac.edge.rda.ecosys)
```